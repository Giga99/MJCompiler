// IMPORT SECTION -------------------------------------------------------------------------------------------------



package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;



// CODE SECTION ---------------------------------------------------------------------------------------------------



parser code {:
	Logger log = Logger.getLogger(getClass());
	
	boolean errorDetected;
   
    // Redefined error handling methods
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
      errorDetected = true;
    }
  
    public void syntax_error(String message, Symbol cur_token) {
        report_error("\nSyntax error: " + message, cur_token);
        errorDetected = true;
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal error, parsing can't be continued", cur_token);
        errorDetected = true;
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" on line ").append(((Symbol)info).left);
        log.error(msg.toString());
        errorDetected = true;
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" on line ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}



// TERMINALS ------------------------------------------------------------------------------------------------------


  
// KEYWORDS
terminal PROG, BREAK, CLASS, ELSE, CONST, IF, WHILE, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, FOREACH;

// OPERATORS
terminal PLUS, MINUS, MUL, DIV, MOD, EQUALS, NOTEQUALS, GRTEATER, GRTEATEREQUALS, LESS, LESSEQUALS, AND, OR, ASSIGN;
terminal INC, DEC, SEMI, COLON, COMMA, DOT, LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACE, RBRACE, ARROW;

// TOKEN TYPES
terminal String BOOL;
terminal Character CHAR;
terminal Integer NUMBER;
terminal String IDENT;



// NONTERMINALS ---------------------------------------------------------------------------------------------------



nonterminal Program, ProgramDeclList, ConstDecl, Type, ConstValue, ConstDeclList, ConstDeclListItem, VarDecl, VarDeclList, VarDeclaration;
nonterminal MethodDeclList, MethodDecl, MethodReturnType, FormParmsDecl, FormParmsList, FormParam;
nonterminal StatementList, Statement, PrintNumOptional, Expr, TermList, Term, Factor, Designator, ActPars;
nonterminal DesignatorStatement;
nonterminal Label, Assignop, Addop, Mulop;



// PRECEDENCE -----------------------------------------------------------------------------------------------------



precedence left ELSE;



// SYNTAX ---------------------------------------------------------------------------------------------------------



Program ::= (Program) PROG IDENT ProgramDeclList LBRACE MethodDeclList RBRACE;



/* Rule for the list of global program variables example:	program Program3 int a; const int b; {} */

ProgramDeclList ::= (ProgramConstDeclList) ProgramDeclList ConstDecl
					|
					(ProgramVarDecList) ProgramDeclList VarDecl
					|
					(ProgramEmptyDeclList) /* epsilon */
					;
					
					

/* Rules for the const declaration */

ConstDecl ::= (ConstDecl) CONST Type ConstDeclList SEMI;

ConstDeclList ::= (ConstDeclListMultipleItems) ConstDeclList COMMA ConstDeclListItem
				| 
				(ConstDeclListSingleItem) ConstDeclListItem
				;
				
ConstDeclListItem ::= (ConstDeclListItem) IDENT ASSIGN ConstValue;

ConstValue ::= (NumberConstValue) NUMBER
			|
			(CharConstValue) CHAR
			|
			(BoolConstValue) BOOL
			;
			
		
		
/* Rules for the variable declaration */	
			
VarDecl ::= (VarDecl) Type VarDeclList SEMI;

VarDeclList ::= (VarDeclListMultipleItems) VarDeclList COMMA VarDeclaration
			|
			(VarDeclListSingleItem) VarDeclaration
			;
			
			
			
/* Rules for the method declaration */
				
MethodDeclList ::= (MethodDeclItemsList) MethodDeclList MethodDecl
				|
				(MethodDeclEmptyList) /* epsilon */
				;
				
MethodDecl ::= (MethodDecl) MethodReturnType IDENT LPAREN FormParmsDecl RPAREN LBRACE StatementList RBRACE;

MethodReturnType ::= (MethodAnyReturnType) Type
					|
					(MethodVoidReturnType) VOID
					;
					
					
					
/* Rules for the formal parameters */
					
FormParmsDecl ::= (FormParsItemsList) FormParmsList
				|
				(FormParsEmptyList) /* epsilon */
				;
				
FormParmsList ::= (FormParmsListMultipleItems) FormParmsList COMMA FormParam
				|
				(FormParmsListSingleItem) FormParam
				;

FormParam ::= (FormParam) Type VarDeclaration;



/* Rules for the methods body */

StatementList ::= (StatementsItemsList) StatementList Statement
				|
				(StatementsEmptyList) /* epsilon */
				;
				
Statement ::= (StatementRead) READ LPAREN Designator RPAREN SEMI /* Rule for the read */
				|
				(StatementPrint) PRINT LPAREN Expr PrintNumOptional RPAREN SEMI /* Rule for the print */
				|
				(StatementDesignator) DesignatorStatement SEMI
				;
				
PrintNumOptional ::= (PrintNumConst) COMMA NUMBER
					|
					(PrintNumNoConst) /* epsilon */
					;
				
				
				
DesignatorStatement ::= (DesignatorStatementAssign) Designator Assignop Expr;
				
				
				
/* Rules for the expressions */
				
Expr ::= (ExprPositiveFirstTerm) TermList
		|
		(ExprNegativeFirstTerm) MINUS TermList
		;

TermList ::= (TermListSingle) Term
			|
			(TermListMultiple) Term Addop TermList /* Rule for the additions and subtractions */
			;

Term ::= (TermSingleFactor) Factor
		|
		(TermMultipleFactor) Term Mulop Factor /* Rule for the mul, div and mod operations */
		;
		
		
		
/* Rules for the factor in expressions */
		
Factor ::= (FactorNumber) NUMBER
		|
		(FactorChar) CHAR
		|
		(FactorBool) BOOL
		|
		(FactorExpr) LPAREN Expr RPAREN /* Rule for the expression inside parentheses, example: (4 + 5 * 3) */
		|
		(FactorNewTypeExpr) NEW Type LSQUARE Expr RSQUARE /* Rule for the array factor */
		|
		(FactorDesignator) Designator
		|
		(FactorMethodCall) Designator LPAREN RPAREN /* Rule for the method call without actual params */
		|
		(FactorMethodCallWithActParams) Designator LPAREN ActPars RPAREN /* Rule for the method call with actual params */
		;
		
		
		
/* Rules for the actual parameters */
		
ActPars ::= (ActParamsMultiple) ActPars COMMA Expr
			|
			(ActParamsSingle) Expr
			;



/* Rules for using variable or accessing element in the array */

Designator ::= (DesignatorIdent) IDENT
			|
			(DesignatorArray) Designator LSQUARE Expr RSQUARE
			;		

		
		
/* Rules for the commonly used things */

Type ::= (Type) IDENT;

Label ::= (Label) IDENT;
			
VarDeclaration ::= (DefaultVar) IDENT
				|
				(ArrayVar) IDENT LSQUARE RSQUARE
				;

Assignop ::= (Assign) ASSIGN;

Addop ::= (Plus) PLUS
		|
		(Minus) MINUS
		;
		
Mulop ::= (Mul) MUL
		|
		(Div) DIV
		|
		(Mod) MOD
		;


